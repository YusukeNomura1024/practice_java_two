ArrayListとLinkedListについて
いくつかListインターフェースを使ったクラスは上記のようなものがありますが
特徴としては次のようなものです。
インデックス指定で要素を取り出すんのであれば、ArrayListの方が早いです。
先頭から順番に処理するのであれば、ArrayListの方が早いです。
そのほか、要素の取り出しに関してはLinkedListの方が早いです。
それに、削除することに関しても、LinkedListの方が早いという特徴があります。

次はMapですね
マップっていうのが何かというと、ハッシュ型みたいなものですね。
キーと値があって、その組み合わせで要素を管理するコレクションですね。
キーはidみたいなもので、同じキーを使うことはできません、
けども、値は重複化のです。個人番号は重複できないけど、
同姓同名の人間がいるのと同じ感じですね。
むしろ、個人番号があるからこそ、同姓同名の名前が付けられる。
これは、キーと値の組み合わせを重視しているため、あまり順番とかは
保証はされませんね。

で、マップの生成はこんな感じです。
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

この3つですね。
で、HashMapを生成する場合は
Map<Integer, String> map1 = new HashMap<Integer, String>();
Listと同じで、変数の方はベースのMapですね。
で、参照型にするので、IntではなくてIntegerですね。
見てわかると思いますが、＜＞の中に2つの型がありますが、
これはキーはIntegerで値がStringということですね。

次はTreeMapを生成する方法ですが、
Map<String, String> map2 = new TreeMap<String, String>();

で、要素を追加するには、
putメソッドを使います、ここで注意点ですが、
存在しているキーを使って追加をしようとすると、もともとの値を上書きしてしまうので
注意しましょう。同じキーは使えないんでしたよね。

map1.put(0, "ブドウ");
map1.put(3, "もも");

このように追加をしていきます。
そのあとに、も一度
map1.put(0, "マスカット");
こう記述してしまうと、キーが被るブドウが上書きされてしまいます。

次に要素の取得ですが、
要素を取得するには、getメソッドを使います。これはListと同じですよね。
存在しないキーを指定した場合は、戻り値がnullになるので予期せぬ挙動につながりますし、
エラーとして帰らないので、注意が必要ですね。

map1.get(0);
map1.get(1)

あとは、要素の存在チェックというものもあります。
これはハッシュ型なら当たり前ですが、
ある要素が含まれるか確認するのは
containsKeyやcontainsValueを使う。
そのまんまの意味ですが、

map1.containsKey(0);
これは、キーに0があるかどうかを確認します。

map1.containsValue("ぶどう");
これは、ぶどうという値が含まれるかを確認します。

で、要素数の取得は
Listと同じで、sizeを使います。

map1.size();

要素の削除に関してはListと同じくremoveを使います。
キーのみか、キーと値の両方の指定
さすがにキーを削除して、値だけ残すのは無理ですね。
キーを削除するのであれば、値も消えます。

List同様に該当する物がなければ何も起こりません。

キーを指定して要素を削除するには
map1.remove(0);
map1.remove(1);この場合は何も起きません

キーと値を指定して要素を削除する
map1.remove(3,"もも");
これだとキーだけ指定するものでいいのではと思うのですが、
より確実に間違いなく削除できそうですよね。
キーがあっていても、値が違っていれば削除されません。



